unit LibraryValesCupones_Async;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROTypes, uROClientIntf, uROAsync,
  {Used RODLs:} DataAbstract4_Intf, DataAbstract4_Async,
  {Project:} LibraryValesCupones_Intf;

type
  TSeekOrigin = Classes.TSeekOrigin; // fake declaration
  { IServiceValesCupones_Async }
  IServiceValesCupones_Async = interface(IDataAbstractService_Async)
    ['{C9240CB9-7B86-45D7-AF5F-2752B68FBF54}']
    procedure Invoke_AbreDataSetReporte(const SQL: AnsiString; const Parametros: TParametros);
    procedure Invoke_FacturaCupon(const Cliente: Integer; const Importe: Double; const EstacionID: Integer;
	const EmpleadoID: Integer; const SerieFactura: AnsiString);
    procedure Invoke_ActualizaCupon(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const PeriodoConsumo: Integer; const Secuencia: Integer;
	const Ticket: Integer; const Liquidacion: Integer);
    procedure Invoke_ActualizaCuponConReferencia(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const PeriodoConsumo: Integer; const Secuencia: Integer;
	const Ticket: Integer; const Referencia: AnsiString);
    procedure Invoke_ActualizaLiquidacionCorte(const Liquidacion: Integer; const Secuencia: Integer; const AgrupacionID: Integer);
    procedure Invoke_ActualizarStatusValeCredito(const CarteraValeCreditoID: Integer; const Status: AnsiString; const FacturaID: Integer);
    procedure Invoke_ActualizaStatusCupon(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const LiquidacionID: Integer; const PeriodoConsumo: Integer;
	const Secuencia: Integer);
    procedure Invoke_BuscaHost(const Tipo: Integer; const Gasolinero: Integer);
    procedure Invoke_BuscaReporte(const Nombre: AnsiString; const TipoTemplate: Integer);
    procedure Invoke_CambiaFolioFactura(const Serie: AnsiString; const Folio: Integer; const NewSerie: AnsiString;
	const NewFolio: Integer);
    procedure Invoke_CancelaFactura(const Folio: Integer; const Serie: AnsiString; const Fecha: DateTime;
	const EstacionID: Integer; const UsuarioID: Integer);
    procedure Invoke_CancelarCupones(const Lista: AnsiString; const UsuarioID: Integer);
    procedure Invoke_CierraLiquidacion(const LiquidacionID: Integer);
    procedure Invoke_CostoProducto(const ProductoID: Integer);
    procedure Invoke_DatosCliente(const ClienteID: Integer; const Referencia: AnsiString);
    procedure Invoke_Existencia(const EstacionID: Integer; const AlmacenID: Integer; const ProductoID: Integer;
	const Fecha: DateTime);
    procedure Invoke_FacturaExpress(const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_FacturaID(const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_FacturaYLiquidacion(const ClienteID: Integer);
    procedure Invoke_Fecha;
    procedure Invoke_Folio(const Campo: AnsiString; const Serie: AnsiString);
    procedure Invoke_FolioActual(const Campo: AnsiString; const Serie: AnsiString);
    procedure Invoke_FolioActual2(const serie: AnsiString; const folio: Integer);
    procedure Invoke_GuardaAccesos(const UsuarioID: Integer; const Lista: AnsiString);
    procedure Invoke_GuardaConsumoExpress(const Consumo: TConsumoExpress);
    procedure Invoke_GuardaLimiteFactura(const UsuarioID: Int64; const Cantidad: Double);
    procedure Invoke_GuardarDatosFactura(const DatosFactura: TDatosFactura);
    procedure Invoke_GuardarDatosLiquidacion(const DatosLiquidacion: TDatosLiquidacion);
    procedure Invoke_GuardarDatosReciboPago(const DatosReciboPago: TDatosReciboPago);
    procedure Invoke_GuardarFacturaExpress(const ClienteID: Integer; const Serie: AnsiString; const EstacionID: Integer;
	const TicketID: Integer);
    procedure Invoke_InsertaDeposito(const DepositoID: Integer; const Cantidad: Double; const Usuario: Integer;
	const Fecha: DateTime; const Secuencia: Integer; const EstacionID: Integer;
	const Descripcion: AnsiString; const Ejercicio: Integer; const Periodo: Integer;
	const Dia: Integer);
    procedure Invoke_GuardaDatosFactura(const DatosFactura: TDatosFactura);
    procedure Invoke_InsertaProductoPrecio(const ProductoID: Integer; const EstacionID: Integer; const Precio: Double);
    procedure Invoke_Login(const Usuario: AnsiString; const Clave: AnsiString);
    procedure Invoke_ModificarFolioActual(const Campo: AnsiString; const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_ObtenerStatusCupon(const Barras: AnsiString);
    procedure Invoke_PrefijaCupon(const nBomba: Integer; const Barras: AnsiString; const Terminal: AnsiString;
	const Grupo: Integer; const ClienteID: Integer);
    procedure Invoke_ObtenerTipoCambioIDPorEstacion(const EstacionID: Integer);
    procedure Invoke_ObtenerTipoCambioPorEstacion(const EstacionID: Integer);
    procedure Invoke_PrecioProducto(const EstacionID: Integer; const ProductoID: Integer);
    procedure Invoke_StatusTicket(const EstacionID: Integer; const TicketID: Integer);
    procedure Invoke_SumaAnticipo(const Estacion: Integer; const Secuencia: Integer);
    procedure Invoke_SumaVentasCorte(const Estacion: Integer; const Secuencia: Integer; const AgrupacionID: Integer);
    procedure Invoke_ValoresTurno(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_VersionServer;
    procedure Invoke_LiquidacionCerrada(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_ClienteValido(const ClienteID: Integer; const NewClienteID: Integer);
    procedure Invoke_BuscaOtroProducto(const EstacionID: Integer; const Codigo: AnsiString);
    procedure Invoke_TurnoALiquidacionID(const TurnoID: Integer; const EstacionID: Integer);
    procedure Invoke_BuscaSagarpa(const EstacionID: Integer);
    procedure Invoke_PuntosCalculaSaldo(const ClienteID: Integer);
    procedure Invoke_PuntosCalculaPuntos(const ClienteID: Integer; const ProductoID: Integer; const Volumen: Double);
    procedure Invoke_PuntosGuardaDatos(const Datos: TDatosPuntos);
    procedure Invoke_PuntosDatos(const ClienteID: Integer);
    procedure Invoke_EliminaAutomaticosLiquidacion(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_BuscaDespachadorLiquidacion(const BombaID: Integer; const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_EntregaPremio(const ClienteID: Integer; const PremioID: Integer; const Cantidad: Integer);
    procedure Invoke_DatosPremio(const PremioID: Integer);
    procedure Invoke_ValidaConsumo(const Consumo: TConsumoExpress);
    procedure Invoke_AgrupacionesBomba(const EstacionID: Integer);
    procedure Invoke_DatosCerrarLiquidacion(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_ProcesaVentasLiquidacion(const Datos: TDatosCerrarLiquidacion);
    procedure Invoke_TicketsLiquidacion(const LiquidacionID: Integer);
    procedure Invoke_ValidaFolioFactura(const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_PuntosGuardaCriterios(const PuntosCriterioID: Integer; const Datos: AnsiString);
    procedure Invoke_DatosFacturaElectronica(const FacturaID: Integer; const EstacionID: Integer);
    procedure Invoke_LlavePrivaCertificado(const LlavePrivada: AnsiString; const Certificado: AnsiString; const GasolineroID: Integer;
	const Password: AnsiString; const EstacionID: Integer);
    procedure Invoke_SELLOPEMs(const Texto: UnicodeString; const EstacionID: Integer);
    procedure Invoke_CERs(const DIR: AnsiString);
    procedure Invoke_ValidaLiquidacionDespachador(const LiquidacionID: Integer);
    procedure Invoke_ActualizaLiquidacionProd(const Estacion: Integer; const FechaIni: DateTime; const FechaFin: DateTime;
	const TurnoID: Integer);
    procedure Invoke_PuntosDespachador(const TurnoID: Integer; const EstacionID: Integer; const UsuarioID: Integer);
    procedure Invoke_GuardarDatosFacturaPemex(const DatosFacturaPemex: TDatosFacturaPemex);
    procedure Invoke_AfectaInventarios(const LiquidacionID: Integer; const UsuarioID: Integer);
    procedure Invoke_InsertaFacturaElectronica(const FacturaElectronicaID: Integer; const CadenaOriginal: UnicodeString;
	const SelloDigital: UnicodeString; const FacturaID: Integer; const Vigencia: Boolean;
	const Enviado: Boolean; const NoCertificado: AnsiString; const NoAprobacion: AnsiString;
	const FechaAprobacion: DateTime);
    procedure Invoke_CERsNUM(const DIR: AnsiString);
    procedure Invoke_ActualizaFirmaDefault(const UsuarioID: Integer; const FIRMA: Binary);
    procedure Invoke_obtendatosempleados(const EstacionID: AnsiString; const Turno: AnsiString);
    procedure Invoke_ProgramaMantenimiento(const IDPROGRAMAMANTENIMIENTO: Integer; const IDESTACION: Integer;
	const FECHA: DateTime);
    procedure Invoke_obtendatosActividadesProgramadas(const IDESTACION: Integer; const TIPO: Integer);
    procedure Invoke_obtenNotificacionesDiarias(const IDESTACION: Integer);
    procedure Invoke_registraactividadrealizada(const IDACTIVIDADMANTENIMIENTO: Integer; const NOTA: AnsiString; const STATUS: AnsiString);
    procedure Invoke_CancelarLote(const LoteID: Integer; const UsuarioID: Integer);
    procedure Invoke_StatusCupon(const Codigo: AnsiString);
    procedure Invoke_BuscarReporte(const Nombre: AnsiString);
    procedure Invoke_GeneraCupones(const LoteCuponID: Integer; const ClienteID: Integer; const EstacionID: Integer;
	const Identificador: Integer; const Cupones: AGeneraCupon; const TipoCupon: Boolean;
	const Serie: AnsiString; const aFolio: Integer);
    procedure Invoke_DocumentosConSaldo(const ClienteID: Integer);
    procedure Invoke_FacturaRecibo(const Cliente: Integer; const Importe: Double; const EstacionID: Integer;
	const EmpleadoID: Integer; const SerieFactura: AnsiString; const ProductoID: Integer);
    procedure Invoke_CaracteresCupon;
    procedure Invoke_ObtenCuponValido(const Barras: AnsiString; const Grupo: Integer; const CuponAutoriza: TAutoriza);
    procedure Invoke_GuardaAutorizacion(const Autorizacion: TAutoriza);
    procedure Invoke_DatosVehiculo(const VehiculoID: Integer);
    procedure Invoke_CancelaGrupo(const Grupo: Integer);
    procedure Invoke_QuemarCupon(const Consumo: TConsumo; const Barras: AnsiString);
    procedure Invoke_GuardarConsumo(const Consumo: TConsumo);
    procedure Invoke_DatosVerifica(const VehiculoID: Integer);
    procedure Invoke_DatosVerificaReferencia(const Referencia: AnsiString);
    procedure Invoke_TarjetaConsumo(const Tarjeta: AnsiString; const Consumo: TConsumo);
    procedure Invoke_ActualizaHistorial(const Consumo: TConsumo);
    procedure Invoke_EliminaAutorizacionVehiculo(const Referencia: AnsiString);
    procedure Invoke_AgregaSecuencias(const Consumos: aConsumo);
    procedure Invoke_AutorizaTarjeta(const Autoriza: TAutoriza);
    procedure Invoke_BuscaAutorizacionTarjeta(const ClienteID: Integer; const VehiculoID: Integer; const GasolineroID: Integer);
    procedure Invoke_EstadoDispensario(const Dispensario: Integer; const Estado: AnsiString);
    procedure Invoke_EntradaBitacora(const Descripcion: AnsiString; const Tipo: eTipoBitacora; const Alerta: Boolean);
    procedure Invoke_AutoCambioPrecio;
    procedure Invoke_CierraTurno(const BombaID: Integer; const TurnoID: Integer; const FinLecturas: aLecturas);
    procedure Invoke_CreaTurno(const BombaID: Integer; const TurnoID: Integer; const InicioLecturas: aLecturas);
    procedure Invoke_GuardaVenta(const nBomba: Integer);
    procedure Invoke_UltimoTurnoBomba;
    procedure Invoke_ValidaSecuencias(const TurnoID: Integer);
    procedure Invoke_ValidaSecuenciasC(const EstacionID: Integer; const Secuencias: AnsiString);
    procedure Invoke_Datos;
    procedure Invoke_CancelaGrupoC(const BombaID: Integer; const Grupo: Integer);
    procedure Invoke_PrefijaGrupo(const Bomba: Integer; const Grupo: Integer; const Terminal: AnsiString;
	const Cupon: TCupon);
    procedure Invoke_PrefijaTarjeta(const nBomba: Integer; const Tarjeta: AnsiString; const NIP: AnsiString;
	const Odometro: AnsiString; const Terminal: AnsiString);
    procedure Invoke_AsignaBombas;
    procedure Invoke_AsignaProductos;
    procedure Invoke_AsignaDispositivo;
    procedure Invoke_AsignaTanques;
    procedure Invoke_IncrementarImpreso(const Secuencia: Integer);
    procedure Invoke_PrefijaTarjetaFrecuente(const nBomba: Integer; const Tarjeta: AnsiString; const Odometro: AnsiString;
	const Terminal: AnsiString);
    procedure Invoke_GenerarFacturas(const Serie: AnsiString; const fol: Integer; const FechaCorte: DateTime;
	const FechaContable: DateTime; const DiaFacturar: Integer; const Magna: Boolean;
	const Premium: Boolean; const Diesel: Boolean; const EmpleadoID: Integer);
    procedure Invoke_EliminaFactura(const Folio: Integer; const Serie: AnsiString);
    procedure Invoke_CambioFactura(const Serie: AnsiString; const Folio: Integer; const NuevaSerie: AnsiString;
	const NuevoFolio: Integer; const FechaImpresion: DateTime);
    procedure Invoke_DatosFactura(const Folio: Integer; const Serie: AnsiString);
    procedure Invoke_GeneraFacturasXCliente(const ClienteID: Integer; const Productos: AnsiString; const FechaCorte: DateTime;
	const FechaContable: DateTime; const Serie: AnsiString; const aFolio: Integer;
	const EmpleadoID: Integer);
    procedure Invoke_GasolineroID;
    function Retrieve_AbreDataSetReporte: Binary;
    function Retrieve_FacturaCupon: Integer;
    function Retrieve_BuscaHost: AnsiString;
    function Retrieve_BuscaReporte: TReporte;
    function Retrieve_CambiaFolioFactura: AnsiString;
    function Retrieve_CancelaFactura: AnsiString;
    function Retrieve_CancelarCupones: AnsiString;
    function Retrieve_CierraLiquidacion: AnsiString;
    function Retrieve_CostoProducto: Double;
    function Retrieve_DatosCliente: TDatosCliente;
    function Retrieve_Existencia: Double;
    function Retrieve_FacturaExpress: TFacturaExpress;
    function Retrieve_FacturaID: Integer;
    function Retrieve_FacturaYLiquidacion: Boolean;
    function Retrieve_Fecha: DateTime;
    function Retrieve_Folio: Integer;
    function Retrieve_FolioActual: Integer;
    function Retrieve_FolioActual2: Integer;
    function Retrieve_GuardaConsumoExpress: Boolean;
    function Retrieve_GuardarFacturaExpress: TFacturaExpress;
    function Retrieve_Login: TLoginInfo;
    function Retrieve_ModificarFolioActual: AnsiString;
    function Retrieve_ObtenerStatusCupon: AnsiString;
    function Retrieve_PrefijaCupon: TCupon;
    function Retrieve_ObtenerTipoCambioIDPorEstacion: Integer;
    function Retrieve_ObtenerTipoCambioPorEstacion: Double;
    function Retrieve_PrecioProducto: Double;
    function Retrieve_StatusTicket: Integer;
    function Retrieve_SumaAnticipo: Double;
    function Retrieve_SumaVentasCorte: Double;
    function Retrieve_ValoresTurno: TValoresTurno;
    function Retrieve_VersionServer: AnsiString;
    function Retrieve_LiquidacionCerrada: Boolean;
    function Retrieve_ClienteValido: Boolean;
    function Retrieve_BuscaOtroProducto: TOtroProducto;
    function Retrieve_TurnoALiquidacionID: Integer;
    function Retrieve_BuscaSagarpa: TSagarpa;
    function Retrieve_PuntosCalculaSaldo: Double;
    function Retrieve_PuntosCalculaPuntos: Double;
    function Retrieve_PuntosDatos: TDatosPuntos;
    function Retrieve_EliminaAutomaticosLiquidacion: Boolean;
    function Retrieve_BuscaDespachadorLiquidacion: Integer;
    function Retrieve_EntregaPremio: TEntregaPremio;
    function Retrieve_DatosPremio: TDatosPremio;
    function Retrieve_ValidaConsumo: Integer;
    function Retrieve_AgrupacionesBomba: AAgrupacion;
    function Retrieve_DatosCerrarLiquidacion: TDatosCerrarLiquidacion;
    function Retrieve_TicketsLiquidacion: AnsiString;
    function Retrieve_ValidaFolioFactura: Boolean;
    function Retrieve_DatosFacturaElectronica: TFacturaElectronica;
    function Retrieve_LlavePrivaCertificado: AnsiString;
    function Retrieve_SELLOPEMs: AnsiString;
    function Retrieve_CERs: AnsiString;
    function Retrieve_ValidaLiquidacionDespachador: AnsiString;
    function Retrieve_ActualizaLiquidacionProd: Boolean;
    function Retrieve_AfectaInventarios: AnsiString;
    function Retrieve_CERsNUM: AnsiString;
    function Retrieve_ActualizaFirmaDefault: AnsiString;
    function Retrieve_obtendatosempleados: AnsiString;
    function Retrieve_obtendatosActividadesProgramadas: AnsiString;
    function Retrieve_obtenNotificacionesDiarias: AnsiString;
    function Retrieve_registraactividadrealizada: AnsiString;
    function Retrieve_CancelarLote: AnsiString;
    function Retrieve_StatusCupon: AnsiString;
    function Retrieve_BuscarReporte: TReporte;
    function Retrieve_DocumentosConSaldo: TDocumentosConSaldoArray;
    function Retrieve_FacturaRecibo: Integer;
    function Retrieve_CaracteresCupon: AnsiString;
    function Retrieve_ObtenCuponValido: TCuponValido;
    function Retrieve_GuardaAutorizacion: Boolean;
    function Retrieve_DatosVehiculo: TDatosVehiculo;
    function Retrieve_CancelaGrupo: Boolean;
    function Retrieve_QuemarCupon: Boolean;
    function Retrieve_GuardarConsumo: Boolean;
    function Retrieve_DatosVerifica: TDatosVerifica;
    function Retrieve_DatosVerificaReferencia: TDatosVerifica;
    function Retrieve_TarjetaConsumo: Boolean;
    function Retrieve_EliminaAutorizacionVehiculo: Boolean;
    function Retrieve_AgregaSecuencias: Boolean;
    function Retrieve_AutorizaTarjeta: TTarjeta;
    function Retrieve_BuscaAutorizacionTarjeta: Boolean;
    function Retrieve_GuardaVenta: Integer;
    function Retrieve_UltimoTurnoBomba: aTurnoBomba;
    function Retrieve_ValidaSecuenciasC: AnsiString;
    function Retrieve_Datos: TGlobal;
    function Retrieve_PrefijaGrupo: AnsiString;
    function Retrieve_PrefijaTarjeta: AnsiString;
    function Retrieve_PrefijaTarjetaFrecuente: AnsiString;
    function Retrieve_GenerarFacturas: Integer;
    function Retrieve_EliminaFactura: Boolean;
    function Retrieve_CambioFactura: AnsiString;
    function Retrieve_DatosFactura: Boolean;
    function Retrieve_GeneraFacturasXCliente: Integer;
    function Retrieve_GasolineroID: Integer;
  end;

  { CoServiceValesCupones_Async }
  CoServiceValesCupones_Async = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IServiceValesCupones_Async;
  end;

  { TServiceValesCupones_AsyncProxy }
  TServiceValesCupones_AsyncProxy = class(TDataAbstractService_AsyncProxy, IServiceValesCupones_Async)
  private
  protected
    function __GetInterfaceName:string; override;

    procedure Invoke_AbreDataSetReporte(const SQL: AnsiString; const Parametros: TParametros);
    procedure Invoke_FacturaCupon(const Cliente: Integer; const Importe: Double; const EstacionID: Integer;
	const EmpleadoID: Integer; const SerieFactura: AnsiString);
    procedure Invoke_ActualizaCupon(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const PeriodoConsumo: Integer; const Secuencia: Integer;
	const Ticket: Integer; const Liquidacion: Integer);
    procedure Invoke_ActualizaCuponConReferencia(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const PeriodoConsumo: Integer; const Secuencia: Integer;
	const Ticket: Integer; const Referencia: AnsiString);
    procedure Invoke_ActualizaLiquidacionCorte(const Liquidacion: Integer; const Secuencia: Integer; const AgrupacionID: Integer);
    procedure Invoke_ActualizarStatusValeCredito(const CarteraValeCreditoID: Integer; const Status: AnsiString; const FacturaID: Integer);
    procedure Invoke_ActualizaStatusCupon(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const LiquidacionID: Integer; const PeriodoConsumo: Integer;
	const Secuencia: Integer);
    procedure Invoke_BuscaHost(const Tipo: Integer; const Gasolinero: Integer);
    procedure Invoke_BuscaReporte(const Nombre: AnsiString; const TipoTemplate: Integer);
    procedure Invoke_CambiaFolioFactura(const Serie: AnsiString; const Folio: Integer; const NewSerie: AnsiString;
	const NewFolio: Integer);
    procedure Invoke_CancelaFactura(const Folio: Integer; const Serie: AnsiString; const Fecha: DateTime;
	const EstacionID: Integer; const UsuarioID: Integer);
    procedure Invoke_CancelarCupones(const Lista: AnsiString; const UsuarioID: Integer);
    procedure Invoke_CierraLiquidacion(const LiquidacionID: Integer);
    procedure Invoke_CostoProducto(const ProductoID: Integer);
    procedure Invoke_DatosCliente(const ClienteID: Integer; const Referencia: AnsiString);
    procedure Invoke_Existencia(const EstacionID: Integer; const AlmacenID: Integer; const ProductoID: Integer;
	const Fecha: DateTime);
    procedure Invoke_FacturaExpress(const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_FacturaID(const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_FacturaYLiquidacion(const ClienteID: Integer);
    procedure Invoke_Fecha;
    procedure Invoke_Folio(const Campo: AnsiString; const Serie: AnsiString);
    procedure Invoke_FolioActual(const Campo: AnsiString; const Serie: AnsiString);
    procedure Invoke_FolioActual2(const serie: AnsiString; const folio: Integer);
    procedure Invoke_GuardaAccesos(const UsuarioID: Integer; const Lista: AnsiString);
    procedure Invoke_GuardaConsumoExpress(const Consumo: TConsumoExpress);
    procedure Invoke_GuardaLimiteFactura(const UsuarioID: Int64; const Cantidad: Double);
    procedure Invoke_GuardarDatosFactura(const DatosFactura: TDatosFactura);
    procedure Invoke_GuardarDatosLiquidacion(const DatosLiquidacion: TDatosLiquidacion);
    procedure Invoke_GuardarDatosReciboPago(const DatosReciboPago: TDatosReciboPago);
    procedure Invoke_GuardarFacturaExpress(const ClienteID: Integer; const Serie: AnsiString; const EstacionID: Integer;
	const TicketID: Integer);
    procedure Invoke_InsertaDeposito(const DepositoID: Integer; const Cantidad: Double; const Usuario: Integer;
	const Fecha: DateTime; const Secuencia: Integer; const EstacionID: Integer;
	const Descripcion: AnsiString; const Ejercicio: Integer; const Periodo: Integer;
	const Dia: Integer);
    procedure Invoke_GuardaDatosFactura(const DatosFactura: TDatosFactura);
    procedure Invoke_InsertaProductoPrecio(const ProductoID: Integer; const EstacionID: Integer; const Precio: Double);
    procedure Invoke_Login(const Usuario: AnsiString; const Clave: AnsiString);
    procedure Invoke_ModificarFolioActual(const Campo: AnsiString; const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_ObtenerStatusCupon(const Barras: AnsiString);
    procedure Invoke_PrefijaCupon(const nBomba: Integer; const Barras: AnsiString; const Terminal: AnsiString;
	const Grupo: Integer; const ClienteID: Integer);
    procedure Invoke_ObtenerTipoCambioIDPorEstacion(const EstacionID: Integer);
    procedure Invoke_ObtenerTipoCambioPorEstacion(const EstacionID: Integer);
    procedure Invoke_PrecioProducto(const EstacionID: Integer; const ProductoID: Integer);
    procedure Invoke_StatusTicket(const EstacionID: Integer; const TicketID: Integer);
    procedure Invoke_SumaAnticipo(const Estacion: Integer; const Secuencia: Integer);
    procedure Invoke_SumaVentasCorte(const Estacion: Integer; const Secuencia: Integer; const AgrupacionID: Integer);
    procedure Invoke_ValoresTurno(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_VersionServer;
    procedure Invoke_LiquidacionCerrada(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_ClienteValido(const ClienteID: Integer; const NewClienteID: Integer);
    procedure Invoke_BuscaOtroProducto(const EstacionID: Integer; const Codigo: AnsiString);
    procedure Invoke_TurnoALiquidacionID(const TurnoID: Integer; const EstacionID: Integer);
    procedure Invoke_BuscaSagarpa(const EstacionID: Integer);
    procedure Invoke_PuntosCalculaSaldo(const ClienteID: Integer);
    procedure Invoke_PuntosCalculaPuntos(const ClienteID: Integer; const ProductoID: Integer; const Volumen: Double);
    procedure Invoke_PuntosGuardaDatos(const Datos: TDatosPuntos);
    procedure Invoke_PuntosDatos(const ClienteID: Integer);
    procedure Invoke_EliminaAutomaticosLiquidacion(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_BuscaDespachadorLiquidacion(const BombaID: Integer; const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_EntregaPremio(const ClienteID: Integer; const PremioID: Integer; const Cantidad: Integer);
    procedure Invoke_DatosPremio(const PremioID: Integer);
    procedure Invoke_ValidaConsumo(const Consumo: TConsumoExpress);
    procedure Invoke_AgrupacionesBomba(const EstacionID: Integer);
    procedure Invoke_DatosCerrarLiquidacion(const EstacionID: Integer; const TurnoID: Integer);
    procedure Invoke_ProcesaVentasLiquidacion(const Datos: TDatosCerrarLiquidacion);
    procedure Invoke_TicketsLiquidacion(const LiquidacionID: Integer);
    procedure Invoke_ValidaFolioFactura(const Serie: AnsiString; const Folio: Integer);
    procedure Invoke_PuntosGuardaCriterios(const PuntosCriterioID: Integer; const Datos: AnsiString);
    procedure Invoke_DatosFacturaElectronica(const FacturaID: Integer; const EstacionID: Integer);
    procedure Invoke_LlavePrivaCertificado(const LlavePrivada: AnsiString; const Certificado: AnsiString; const GasolineroID: Integer;
	const Password: AnsiString; const EstacionID: Integer);
    procedure Invoke_SELLOPEMs(const Texto: UnicodeString; const EstacionID: Integer);
    procedure Invoke_CERs(const DIR: AnsiString);
    procedure Invoke_ValidaLiquidacionDespachador(const LiquidacionID: Integer);
    procedure Invoke_ActualizaLiquidacionProd(const Estacion: Integer; const FechaIni: DateTime; const FechaFin: DateTime;
	const TurnoID: Integer);
    procedure Invoke_PuntosDespachador(const TurnoID: Integer; const EstacionID: Integer; const UsuarioID: Integer);
    procedure Invoke_GuardarDatosFacturaPemex(const DatosFacturaPemex: TDatosFacturaPemex);
    procedure Invoke_AfectaInventarios(const LiquidacionID: Integer; const UsuarioID: Integer);
    procedure Invoke_InsertaFacturaElectronica(const FacturaElectronicaID: Integer; const CadenaOriginal: UnicodeString;
	const SelloDigital: UnicodeString; const FacturaID: Integer; const Vigencia: Boolean;
	const Enviado: Boolean; const NoCertificado: AnsiString; const NoAprobacion: AnsiString;
	const FechaAprobacion: DateTime);
    procedure Invoke_CERsNUM(const DIR: AnsiString);
    procedure Invoke_ActualizaFirmaDefault(const UsuarioID: Integer; const FIRMA: Binary);
    procedure Invoke_obtendatosempleados(const EstacionID: AnsiString; const Turno: AnsiString);
    procedure Invoke_ProgramaMantenimiento(const IDPROGRAMAMANTENIMIENTO: Integer; const IDESTACION: Integer;
	const FECHA: DateTime);
    procedure Invoke_obtendatosActividadesProgramadas(const IDESTACION: Integer; const TIPO: Integer);
    procedure Invoke_obtenNotificacionesDiarias(const IDESTACION: Integer);
    procedure Invoke_registraactividadrealizada(const IDACTIVIDADMANTENIMIENTO: Integer; const NOTA: AnsiString; const STATUS: AnsiString);
    procedure Invoke_CancelarLote(const LoteID: Integer; const UsuarioID: Integer);
    procedure Invoke_StatusCupon(const Codigo: AnsiString);
    procedure Invoke_BuscarReporte(const Nombre: AnsiString);
    procedure Invoke_GeneraCupones(const LoteCuponID: Integer; const ClienteID: Integer; const EstacionID: Integer;
	const Identificador: Integer; const Cupones: AGeneraCupon; const TipoCupon: Boolean;
	const Serie: AnsiString; const aFolio: Integer);
    procedure Invoke_DocumentosConSaldo(const ClienteID: Integer);
    procedure Invoke_FacturaRecibo(const Cliente: Integer; const Importe: Double; const EstacionID: Integer;
	const EmpleadoID: Integer; const SerieFactura: AnsiString; const ProductoID: Integer);
    procedure Invoke_CaracteresCupon;
    procedure Invoke_ObtenCuponValido(const Barras: AnsiString; const Grupo: Integer; const CuponAutoriza: TAutoriza);
    procedure Invoke_GuardaAutorizacion(const Autorizacion: TAutoriza);
    procedure Invoke_DatosVehiculo(const VehiculoID: Integer);
    procedure Invoke_CancelaGrupo(const Grupo: Integer);
    procedure Invoke_QuemarCupon(const Consumo: TConsumo; const Barras: AnsiString);
    procedure Invoke_GuardarConsumo(const Consumo: TConsumo);
    procedure Invoke_DatosVerifica(const VehiculoID: Integer);
    procedure Invoke_DatosVerificaReferencia(const Referencia: AnsiString);
    procedure Invoke_TarjetaConsumo(const Tarjeta: AnsiString; const Consumo: TConsumo);
    procedure Invoke_ActualizaHistorial(const Consumo: TConsumo);
    procedure Invoke_EliminaAutorizacionVehiculo(const Referencia: AnsiString);
    procedure Invoke_AgregaSecuencias(const Consumos: aConsumo);
    procedure Invoke_AutorizaTarjeta(const Autoriza: TAutoriza);
    procedure Invoke_BuscaAutorizacionTarjeta(const ClienteID: Integer; const VehiculoID: Integer; const GasolineroID: Integer);
    procedure Invoke_EstadoDispensario(const Dispensario: Integer; const Estado: AnsiString);
    procedure Invoke_EntradaBitacora(const Descripcion: AnsiString; const Tipo: eTipoBitacora; const Alerta: Boolean);
    procedure Invoke_AutoCambioPrecio;
    procedure Invoke_CierraTurno(const BombaID: Integer; const TurnoID: Integer; const FinLecturas: aLecturas);
    procedure Invoke_CreaTurno(const BombaID: Integer; const TurnoID: Integer; const InicioLecturas: aLecturas);
    procedure Invoke_GuardaVenta(const nBomba: Integer);
    procedure Invoke_UltimoTurnoBomba;
    procedure Invoke_ValidaSecuencias(const TurnoID: Integer);
    procedure Invoke_ValidaSecuenciasC(const EstacionID: Integer; const Secuencias: AnsiString);
    procedure Invoke_Datos;
    procedure Invoke_CancelaGrupoC(const BombaID: Integer; const Grupo: Integer);
    procedure Invoke_PrefijaGrupo(const Bomba: Integer; const Grupo: Integer; const Terminal: AnsiString;
	const Cupon: TCupon);
    procedure Invoke_PrefijaTarjeta(const nBomba: Integer; const Tarjeta: AnsiString; const NIP: AnsiString;
	const Odometro: AnsiString; const Terminal: AnsiString);
    procedure Invoke_AsignaBombas;
    procedure Invoke_AsignaProductos;
    procedure Invoke_AsignaDispositivo;
    procedure Invoke_AsignaTanques;
    procedure Invoke_IncrementarImpreso(const Secuencia: Integer);
    procedure Invoke_PrefijaTarjetaFrecuente(const nBomba: Integer; const Tarjeta: AnsiString; const Odometro: AnsiString;
	const Terminal: AnsiString);
    procedure Invoke_GenerarFacturas(const Serie: AnsiString; const fol: Integer; const FechaCorte: DateTime;
	const FechaContable: DateTime; const DiaFacturar: Integer; const Magna: Boolean;
	const Premium: Boolean; const Diesel: Boolean; const EmpleadoID: Integer);
    procedure Invoke_EliminaFactura(const Folio: Integer; const Serie: AnsiString);
    procedure Invoke_CambioFactura(const Serie: AnsiString; const Folio: Integer; const NuevaSerie: AnsiString;
	const NuevoFolio: Integer; const FechaImpresion: DateTime);
    procedure Invoke_DatosFactura(const Folio: Integer; const Serie: AnsiString);
    procedure Invoke_GeneraFacturasXCliente(const ClienteID: Integer; const Productos: AnsiString; const FechaCorte: DateTime;
	const FechaContable: DateTime; const Serie: AnsiString; const aFolio: Integer;
	const EmpleadoID: Integer);
    procedure Invoke_GasolineroID;
    function Retrieve_AbreDataSetReporte: Binary;
    function Retrieve_FacturaCupon: Integer;
    function Retrieve_BuscaHost: AnsiString;
    function Retrieve_BuscaReporte: TReporte;
    function Retrieve_CambiaFolioFactura: AnsiString;
    function Retrieve_CancelaFactura: AnsiString;
    function Retrieve_CancelarCupones: AnsiString;
    function Retrieve_CierraLiquidacion: AnsiString;
    function Retrieve_CostoProducto: Double;
    function Retrieve_DatosCliente: TDatosCliente;
    function Retrieve_Existencia: Double;
    function Retrieve_FacturaExpress: TFacturaExpress;
    function Retrieve_FacturaID: Integer;
    function Retrieve_FacturaYLiquidacion: Boolean;
    function Retrieve_Fecha: DateTime;
    function Retrieve_Folio: Integer;
    function Retrieve_FolioActual: Integer;
    function Retrieve_FolioActual2: Integer;
    function Retrieve_GuardaConsumoExpress: Boolean;
    function Retrieve_GuardarFacturaExpress: TFacturaExpress;
    function Retrieve_Login: TLoginInfo;
    function Retrieve_ModificarFolioActual: AnsiString;
    function Retrieve_ObtenerStatusCupon: AnsiString;
    function Retrieve_PrefijaCupon: TCupon;
    function Retrieve_ObtenerTipoCambioIDPorEstacion: Integer;
    function Retrieve_ObtenerTipoCambioPorEstacion: Double;
    function Retrieve_PrecioProducto: Double;
    function Retrieve_StatusTicket: Integer;
    function Retrieve_SumaAnticipo: Double;
    function Retrieve_SumaVentasCorte: Double;
    function Retrieve_ValoresTurno: TValoresTurno;
    function Retrieve_VersionServer: AnsiString;
    function Retrieve_LiquidacionCerrada: Boolean;
    function Retrieve_ClienteValido: Boolean;
    function Retrieve_BuscaOtroProducto: TOtroProducto;
    function Retrieve_TurnoALiquidacionID: Integer;
    function Retrieve_BuscaSagarpa: TSagarpa;
    function Retrieve_PuntosCalculaSaldo: Double;
    function Retrieve_PuntosCalculaPuntos: Double;
    function Retrieve_PuntosDatos: TDatosPuntos;
    function Retrieve_EliminaAutomaticosLiquidacion: Boolean;
    function Retrieve_BuscaDespachadorLiquidacion: Integer;
    function Retrieve_EntregaPremio: TEntregaPremio;
    function Retrieve_DatosPremio: TDatosPremio;
    function Retrieve_ValidaConsumo: Integer;
    function Retrieve_AgrupacionesBomba: AAgrupacion;
    function Retrieve_DatosCerrarLiquidacion: TDatosCerrarLiquidacion;
    function Retrieve_TicketsLiquidacion: AnsiString;
    function Retrieve_ValidaFolioFactura: Boolean;
    function Retrieve_DatosFacturaElectronica: TFacturaElectronica;
    function Retrieve_LlavePrivaCertificado: AnsiString;
    function Retrieve_SELLOPEMs: AnsiString;
    function Retrieve_CERs: AnsiString;
    function Retrieve_ValidaLiquidacionDespachador: AnsiString;
    function Retrieve_ActualizaLiquidacionProd: Boolean;
    function Retrieve_AfectaInventarios: AnsiString;
    function Retrieve_CERsNUM: AnsiString;
    function Retrieve_ActualizaFirmaDefault: AnsiString;
    function Retrieve_obtendatosempleados: AnsiString;
    function Retrieve_obtendatosActividadesProgramadas: AnsiString;
    function Retrieve_obtenNotificacionesDiarias: AnsiString;
    function Retrieve_registraactividadrealizada: AnsiString;
    function Retrieve_CancelarLote: AnsiString;
    function Retrieve_StatusCupon: AnsiString;
    function Retrieve_BuscarReporte: TReporte;
    function Retrieve_DocumentosConSaldo: TDocumentosConSaldoArray;
    function Retrieve_FacturaRecibo: Integer;
    function Retrieve_CaracteresCupon: AnsiString;
    function Retrieve_ObtenCuponValido: TCuponValido;
    function Retrieve_GuardaAutorizacion: Boolean;
    function Retrieve_DatosVehiculo: TDatosVehiculo;
    function Retrieve_CancelaGrupo: Boolean;
    function Retrieve_QuemarCupon: Boolean;
    function Retrieve_GuardarConsumo: Boolean;
    function Retrieve_DatosVerifica: TDatosVerifica;
    function Retrieve_DatosVerificaReferencia: TDatosVerifica;
    function Retrieve_TarjetaConsumo: Boolean;
    function Retrieve_EliminaAutorizacionVehiculo: Boolean;
    function Retrieve_AgregaSecuencias: Boolean;
    function Retrieve_AutorizaTarjeta: TTarjeta;
    function Retrieve_BuscaAutorizacionTarjeta: Boolean;
    function Retrieve_GuardaVenta: Integer;
    function Retrieve_UltimoTurnoBomba: aTurnoBomba;
    function Retrieve_ValidaSecuenciasC: AnsiString;
    function Retrieve_Datos: TGlobal;
    function Retrieve_PrefijaGrupo: AnsiString;
    function Retrieve_PrefijaTarjeta: AnsiString;
    function Retrieve_PrefijaTarjetaFrecuente: AnsiString;
    function Retrieve_GenerarFacturas: Integer;
    function Retrieve_EliminaFactura: Boolean;
    function Retrieve_CambioFactura: AnsiString;
    function Retrieve_DatosFactura: Boolean;
    function Retrieve_GeneraFacturasXCliente: Integer;
    function Retrieve_GasolineroID: Integer;
  end;

implementation

uses
  {vcl:} SysUtils,
  {RemObjects:} uROTransportChannel, uROExceptions;

{ CoServiceValesCupones }

class function CoServiceValesCupones_Async.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IServiceValesCupones_Async;
begin
  result := TServiceValesCupones_AsyncProxy.Create(aMessage, aTransportChannel);
end;

{ TServiceValesCupones_AsyncProxy }

function TServiceValesCupones_AsyncProxy.__GetInterfaceName:string;
begin
  result := 'ServiceValesCupones';
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AbreDataSetReporte(const SQL: AnsiString; const Parametros: TParametros);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AbreDataSetReporte');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AbreDataSetReporte');
    lMessage.Write('SQL', TypeInfo(AnsiString), SQL, []);
    lMessage.Write('Parametros', TypeInfo(TParametros), Parametros, []);
    __DispatchAsyncRequest('AbreDataSetReporte',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_AbreDataSetReporte: Binary;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('AbreDataSetReporte');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Binary), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FacturaCupon(const Cliente: Integer; const Importe: Double; const EstacionID: Integer;
	const EmpleadoID: Integer; const SerieFactura: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FacturaCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FacturaCupon');
    lMessage.Write('Cliente', TypeInfo(Integer), Cliente, []);
    lMessage.Write('Importe', TypeInfo(Double), Importe, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('EmpleadoID', TypeInfo(Integer), EmpleadoID, []);
    lMessage.Write('SerieFactura', TypeInfo(AnsiString), SerieFactura, []);
    __DispatchAsyncRequest('FacturaCupon',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FacturaCupon: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('FacturaCupon');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaCupon(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const PeriodoConsumo: Integer; const Secuencia: Integer;
	const Ticket: Integer; const Liquidacion: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaCupon');
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    lMessage.Write('DiaConsumo', TypeInfo(Integer), DiaConsumo, []);
    lMessage.Write('EjercicioConsumo', TypeInfo(Integer), EjercicioConsumo, []);
    lMessage.Write('FechaConsumo', TypeInfo(DateTime), FechaConsumo, [paIsDateTime]);
    lMessage.Write('PeriodoConsumo', TypeInfo(Integer), PeriodoConsumo, []);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    lMessage.Write('Ticket', TypeInfo(Integer), Ticket, []);
    lMessage.Write('Liquidacion', TypeInfo(Integer), Liquidacion, []);
    __DispatchAsyncRequest('ActualizaCupon',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaCuponConReferencia(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const PeriodoConsumo: Integer; const Secuencia: Integer;
	const Ticket: Integer; const Referencia: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaCuponConReferencia');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaCuponConReferencia');
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    lMessage.Write('DiaConsumo', TypeInfo(Integer), DiaConsumo, []);
    lMessage.Write('EjercicioConsumo', TypeInfo(Integer), EjercicioConsumo, []);
    lMessage.Write('FechaConsumo', TypeInfo(DateTime), FechaConsumo, [paIsDateTime]);
    lMessage.Write('PeriodoConsumo', TypeInfo(Integer), PeriodoConsumo, []);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    lMessage.Write('Ticket', TypeInfo(Integer), Ticket, []);
    lMessage.Write('Referencia', TypeInfo(AnsiString), Referencia, []);
    __DispatchAsyncRequest('ActualizaCuponConReferencia',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaLiquidacionCorte(const Liquidacion: Integer; const Secuencia: Integer; const AgrupacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaLiquidacionCorte');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaLiquidacionCorte');
    lMessage.Write('Liquidacion', TypeInfo(Integer), Liquidacion, []);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    lMessage.Write('AgrupacionID', TypeInfo(Integer), AgrupacionID, []);
    __DispatchAsyncRequest('ActualizaLiquidacionCorte',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizarStatusValeCredito(const CarteraValeCreditoID: Integer; const Status: AnsiString; const FacturaID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizarStatusValeCredito');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizarStatusValeCredito');
    lMessage.Write('CarteraValeCreditoID', TypeInfo(Integer), CarteraValeCreditoID, []);
    lMessage.Write('Status', TypeInfo(AnsiString), Status, []);
    lMessage.Write('FacturaID', TypeInfo(Integer), FacturaID, []);
    __DispatchAsyncRequest('ActualizarStatusValeCredito',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaStatusCupon(const Barras: AnsiString; const DiaConsumo: Integer; const EjercicioConsumo: Integer;
	const FechaConsumo: DateTime; const LiquidacionID: Integer; const PeriodoConsumo: Integer;
	const Secuencia: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaStatusCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaStatusCupon');
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    lMessage.Write('DiaConsumo', TypeInfo(Integer), DiaConsumo, []);
    lMessage.Write('EjercicioConsumo', TypeInfo(Integer), EjercicioConsumo, []);
    lMessage.Write('FechaConsumo', TypeInfo(DateTime), FechaConsumo, [paIsDateTime]);
    lMessage.Write('LiquidacionID', TypeInfo(Integer), LiquidacionID, []);
    lMessage.Write('PeriodoConsumo', TypeInfo(Integer), PeriodoConsumo, []);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    __DispatchAsyncRequest('ActualizaStatusCupon',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscaHost(const Tipo: Integer; const Gasolinero: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscaHost');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscaHost');
    lMessage.Write('Tipo', TypeInfo(Integer), Tipo, []);
    lMessage.Write('Gasolinero', TypeInfo(Integer), Gasolinero, []);
    __DispatchAsyncRequest('BuscaHost',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscaHost: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('BuscaHost');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscaReporte(const Nombre: AnsiString; const TipoTemplate: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscaReporte');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscaReporte');
    lMessage.Write('Nombre', TypeInfo(AnsiString), Nombre, []);
    lMessage.Write('TipoTemplate', TypeInfo(Integer), TipoTemplate, []);
    __DispatchAsyncRequest('BuscaReporte',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscaReporte: TReporte;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('BuscaReporte');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TReporte), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CambiaFolioFactura(const Serie: AnsiString; const Folio: Integer; const NewSerie: AnsiString;
	const NewFolio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CambiaFolioFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CambiaFolioFactura');
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    lMessage.Write('NewSerie', TypeInfo(AnsiString), NewSerie, []);
    lMessage.Write('NewFolio', TypeInfo(Integer), NewFolio, []);
    __DispatchAsyncRequest('CambiaFolioFactura',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CambiaFolioFactura: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CambiaFolioFactura');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CancelaFactura(const Folio: Integer; const Serie: AnsiString; const Fecha: DateTime;
	const EstacionID: Integer; const UsuarioID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CancelaFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CancelaFactura');
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Fecha', TypeInfo(DateTime), Fecha, [paIsDateTime]);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    __DispatchAsyncRequest('CancelaFactura',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CancelaFactura: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CancelaFactura');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CancelarCupones(const Lista: AnsiString; const UsuarioID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CancelarCupones');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CancelarCupones');
    lMessage.Write('Lista', TypeInfo(AnsiString), Lista, []);
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    __DispatchAsyncRequest('CancelarCupones',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CancelarCupones: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CancelarCupones');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CierraLiquidacion(const LiquidacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CierraLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CierraLiquidacion');
    lMessage.Write('LiquidacionID', TypeInfo(Integer), LiquidacionID, []);
    __DispatchAsyncRequest('CierraLiquidacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CierraLiquidacion: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CierraLiquidacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CostoProducto(const ProductoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CostoProducto');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CostoProducto');
    lMessage.Write('ProductoID', TypeInfo(Integer), ProductoID, []);
    __DispatchAsyncRequest('CostoProducto',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CostoProducto: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CostoProducto');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosCliente(const ClienteID: Integer; const Referencia: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosCliente');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosCliente');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('Referencia', TypeInfo(AnsiString), Referencia, []);
    __DispatchAsyncRequest('DatosCliente',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosCliente: TDatosCliente;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosCliente');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosCliente), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_Existencia(const EstacionID: Integer; const AlmacenID: Integer; const ProductoID: Integer;
	const Fecha: DateTime);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('Existencia');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'Existencia');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('AlmacenID', TypeInfo(Integer), AlmacenID, []);
    lMessage.Write('ProductoID', TypeInfo(Integer), ProductoID, []);
    lMessage.Write('Fecha', TypeInfo(DateTime), Fecha, [paIsDateTime]);
    __DispatchAsyncRequest('Existencia',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_Existencia: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('Existencia');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FacturaExpress(const Serie: AnsiString; const Folio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FacturaExpress');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FacturaExpress');
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    __DispatchAsyncRequest('FacturaExpress',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FacturaExpress: TFacturaExpress;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('FacturaExpress');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TFacturaExpress), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FacturaID(const Serie: AnsiString; const Folio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FacturaID');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FacturaID');
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    __DispatchAsyncRequest('FacturaID',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FacturaID: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('FacturaID');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FacturaYLiquidacion(const ClienteID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FacturaYLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FacturaYLiquidacion');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    __DispatchAsyncRequest('FacturaYLiquidacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FacturaYLiquidacion: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('FacturaYLiquidacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_Fecha;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('Fecha');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'Fecha');
    __DispatchAsyncRequest('Fecha',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_Fecha: DateTime;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('Fecha');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(DateTime), Result, [paIsDateTime]);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_Folio(const Campo: AnsiString; const Serie: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('Folio');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'Folio');
    lMessage.Write('Campo', TypeInfo(AnsiString), Campo, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    __DispatchAsyncRequest('Folio',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_Folio: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('Folio');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FolioActual(const Campo: AnsiString; const Serie: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FolioActual');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FolioActual');
    lMessage.Write('Campo', TypeInfo(AnsiString), Campo, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    __DispatchAsyncRequest('FolioActual',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FolioActual: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('FolioActual');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FolioActual2(const serie: AnsiString; const folio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FolioActual2');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FolioActual2');
    lMessage.Write('serie', TypeInfo(AnsiString), serie, []);
    lMessage.Write('folio', TypeInfo(Integer), folio, []);
    __DispatchAsyncRequest('FolioActual2',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FolioActual2: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('FolioActual2');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardaAccesos(const UsuarioID: Integer; const Lista: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardaAccesos');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardaAccesos');
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    lMessage.Write('Lista', TypeInfo(AnsiString), Lista, []);
    __DispatchAsyncRequest('GuardaAccesos',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardaConsumoExpress(const Consumo: TConsumoExpress);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardaConsumoExpress');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardaConsumoExpress');
    lMessage.Write('Consumo', TypeInfo(TConsumoExpress), Consumo, []);
    __DispatchAsyncRequest('GuardaConsumoExpress',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GuardaConsumoExpress: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GuardaConsumoExpress');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardaLimiteFactura(const UsuarioID: Int64; const Cantidad: Double);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardaLimiteFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardaLimiteFactura');
    lMessage.Write('UsuarioID', TypeInfo(Int64), UsuarioID, []);
    lMessage.Write('Cantidad', TypeInfo(Double), Cantidad, []);
    __DispatchAsyncRequest('GuardaLimiteFactura',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardarDatosFactura(const DatosFactura: TDatosFactura);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardarDatosFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardarDatosFactura');
    lMessage.Write('DatosFactura', TypeInfo(TDatosFactura), DatosFactura, []);
    __DispatchAsyncRequest('GuardarDatosFactura',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardarDatosLiquidacion(const DatosLiquidacion: TDatosLiquidacion);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardarDatosLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardarDatosLiquidacion');
    lMessage.Write('DatosLiquidacion', TypeInfo(TDatosLiquidacion), DatosLiquidacion, []);
    __DispatchAsyncRequest('GuardarDatosLiquidacion',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardarDatosReciboPago(const DatosReciboPago: TDatosReciboPago);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardarDatosReciboPago');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardarDatosReciboPago');
    lMessage.Write('DatosReciboPago', TypeInfo(TDatosReciboPago), DatosReciboPago, []);
    __DispatchAsyncRequest('GuardarDatosReciboPago',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardarFacturaExpress(const ClienteID: Integer; const Serie: AnsiString; const EstacionID: Integer;
	const TicketID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardarFacturaExpress');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardarFacturaExpress');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TicketID', TypeInfo(Integer), TicketID, []);
    __DispatchAsyncRequest('GuardarFacturaExpress',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GuardarFacturaExpress: TFacturaExpress;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('GuardarFacturaExpress');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TFacturaExpress), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_InsertaDeposito(const DepositoID: Integer; const Cantidad: Double; const Usuario: Integer;
	const Fecha: DateTime; const Secuencia: Integer; const EstacionID: Integer;
	const Descripcion: AnsiString; const Ejercicio: Integer; const Periodo: Integer;
	const Dia: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('InsertaDeposito');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'InsertaDeposito');
    lMessage.Write('DepositoID', TypeInfo(Integer), DepositoID, []);
    lMessage.Write('Cantidad', TypeInfo(Double), Cantidad, []);
    lMessage.Write('Usuario', TypeInfo(Integer), Usuario, []);
    lMessage.Write('Fecha', TypeInfo(DateTime), Fecha, [paIsDateTime]);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('Descripcion', TypeInfo(AnsiString), Descripcion, []);
    lMessage.Write('Ejercicio', TypeInfo(Integer), Ejercicio, []);
    lMessage.Write('Periodo', TypeInfo(Integer), Periodo, []);
    lMessage.Write('Dia', TypeInfo(Integer), Dia, []);
    __DispatchAsyncRequest('InsertaDeposito',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardaDatosFactura(const DatosFactura: TDatosFactura);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardaDatosFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardaDatosFactura');
    lMessage.Write('DatosFactura', TypeInfo(TDatosFactura), DatosFactura, []);
    __DispatchAsyncRequest('GuardaDatosFactura',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_InsertaProductoPrecio(const ProductoID: Integer; const EstacionID: Integer; const Precio: Double);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('InsertaProductoPrecio');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'InsertaProductoPrecio');
    lMessage.Write('ProductoID', TypeInfo(Integer), ProductoID, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('Precio', TypeInfo(Double), Precio, []);
    __DispatchAsyncRequest('InsertaProductoPrecio',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_Login(const Usuario: AnsiString; const Clave: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('Login');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'Login');
    lMessage.Write('Usuario', TypeInfo(AnsiString), Usuario, []);
    lMessage.Write('Clave', TypeInfo(AnsiString), Clave, []);
    __DispatchAsyncRequest('Login',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_Login: TLoginInfo;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('Login');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TLoginInfo), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ModificarFolioActual(const Campo: AnsiString; const Serie: AnsiString; const Folio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ModificarFolioActual');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ModificarFolioActual');
    lMessage.Write('Campo', TypeInfo(AnsiString), Campo, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    __DispatchAsyncRequest('ModificarFolioActual',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ModificarFolioActual: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ModificarFolioActual');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ObtenerStatusCupon(const Barras: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ObtenerStatusCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ObtenerStatusCupon');
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    __DispatchAsyncRequest('ObtenerStatusCupon',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ObtenerStatusCupon: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ObtenerStatusCupon');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PrefijaCupon(const nBomba: Integer; const Barras: AnsiString; const Terminal: AnsiString;
	const Grupo: Integer; const ClienteID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PrefijaCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PrefijaCupon');
    lMessage.Write('nBomba', TypeInfo(Integer), nBomba, []);
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    lMessage.Write('Terminal', TypeInfo(AnsiString), Terminal, []);
    lMessage.Write('Grupo', TypeInfo(Integer), Grupo, []);
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    __DispatchAsyncRequest('PrefijaCupon',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PrefijaCupon: TCupon;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('PrefijaCupon');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TCupon), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ObtenerTipoCambioIDPorEstacion(const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ObtenerTipoCambioIDPorEstacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ObtenerTipoCambioIDPorEstacion');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('ObtenerTipoCambioIDPorEstacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ObtenerTipoCambioIDPorEstacion: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ObtenerTipoCambioIDPorEstacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ObtenerTipoCambioPorEstacion(const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ObtenerTipoCambioPorEstacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ObtenerTipoCambioPorEstacion');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('ObtenerTipoCambioPorEstacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ObtenerTipoCambioPorEstacion: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ObtenerTipoCambioPorEstacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PrecioProducto(const EstacionID: Integer; const ProductoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PrecioProducto');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PrecioProducto');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('ProductoID', TypeInfo(Integer), ProductoID, []);
    __DispatchAsyncRequest('PrecioProducto',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PrecioProducto: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('PrecioProducto');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_StatusTicket(const EstacionID: Integer; const TicketID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('StatusTicket');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'StatusTicket');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TicketID', TypeInfo(Integer), TicketID, []);
    __DispatchAsyncRequest('StatusTicket',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_StatusTicket: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('StatusTicket');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_SumaAnticipo(const Estacion: Integer; const Secuencia: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('SumaAnticipo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'SumaAnticipo');
    lMessage.Write('Estacion', TypeInfo(Integer), Estacion, []);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    __DispatchAsyncRequest('SumaAnticipo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_SumaAnticipo: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('SumaAnticipo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_SumaVentasCorte(const Estacion: Integer; const Secuencia: Integer; const AgrupacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('SumaVentasCorte');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'SumaVentasCorte');
    lMessage.Write('Estacion', TypeInfo(Integer), Estacion, []);
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    lMessage.Write('AgrupacionID', TypeInfo(Integer), AgrupacionID, []);
    __DispatchAsyncRequest('SumaVentasCorte',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_SumaVentasCorte: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('SumaVentasCorte');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ValoresTurno(const EstacionID: Integer; const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ValoresTurno');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ValoresTurno');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('ValoresTurno',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ValoresTurno: TValoresTurno;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('ValoresTurno');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TValoresTurno), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_VersionServer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('VersionServer');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'VersionServer');
    __DispatchAsyncRequest('VersionServer',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_VersionServer: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('VersionServer');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_LiquidacionCerrada(const EstacionID: Integer; const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('LiquidacionCerrada');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'LiquidacionCerrada');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('LiquidacionCerrada',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_LiquidacionCerrada: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('LiquidacionCerrada');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ClienteValido(const ClienteID: Integer; const NewClienteID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ClienteValido');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ClienteValido');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('NewClienteID', TypeInfo(Integer), NewClienteID, []);
    __DispatchAsyncRequest('ClienteValido',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ClienteValido: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ClienteValido');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscaOtroProducto(const EstacionID: Integer; const Codigo: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscaOtroProducto');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscaOtroProducto');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('Codigo', TypeInfo(AnsiString), Codigo, []);
    __DispatchAsyncRequest('BuscaOtroProducto',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscaOtroProducto: TOtroProducto;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('BuscaOtroProducto');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TOtroProducto), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_TurnoALiquidacionID(const TurnoID: Integer; const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('TurnoALiquidacionID');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'TurnoALiquidacionID');
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('TurnoALiquidacionID',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_TurnoALiquidacionID: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('TurnoALiquidacionID');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscaSagarpa(const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscaSagarpa');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscaSagarpa');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('BuscaSagarpa',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscaSagarpa: TSagarpa;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('BuscaSagarpa');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TSagarpa), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PuntosCalculaSaldo(const ClienteID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PuntosCalculaSaldo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PuntosCalculaSaldo');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    __DispatchAsyncRequest('PuntosCalculaSaldo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PuntosCalculaSaldo: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('PuntosCalculaSaldo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PuntosCalculaPuntos(const ClienteID: Integer; const ProductoID: Integer; const Volumen: Double);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PuntosCalculaPuntos');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PuntosCalculaPuntos');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('ProductoID', TypeInfo(Integer), ProductoID, []);
    lMessage.Write('Volumen', TypeInfo(Double), Volumen, []);
    __DispatchAsyncRequest('PuntosCalculaPuntos',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PuntosCalculaPuntos: Double;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('PuntosCalculaPuntos');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Double), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PuntosGuardaDatos(const Datos: TDatosPuntos);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PuntosGuardaDatos');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PuntosGuardaDatos');
    lMessage.Write('Datos', TypeInfo(TDatosPuntos), Datos, []);
    __DispatchAsyncRequest('PuntosGuardaDatos',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PuntosDatos(const ClienteID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PuntosDatos');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PuntosDatos');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    __DispatchAsyncRequest('PuntosDatos',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PuntosDatos: TDatosPuntos;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('PuntosDatos');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosPuntos), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_EliminaAutomaticosLiquidacion(const EstacionID: Integer; const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('EliminaAutomaticosLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'EliminaAutomaticosLiquidacion');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('EliminaAutomaticosLiquidacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_EliminaAutomaticosLiquidacion: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('EliminaAutomaticosLiquidacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscaDespachadorLiquidacion(const BombaID: Integer; const EstacionID: Integer; const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscaDespachadorLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscaDespachadorLiquidacion');
    lMessage.Write('BombaID', TypeInfo(Integer), BombaID, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('BuscaDespachadorLiquidacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscaDespachadorLiquidacion: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('BuscaDespachadorLiquidacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_EntregaPremio(const ClienteID: Integer; const PremioID: Integer; const Cantidad: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('EntregaPremio');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'EntregaPremio');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('PremioID', TypeInfo(Integer), PremioID, []);
    lMessage.Write('Cantidad', TypeInfo(Integer), Cantidad, []);
    __DispatchAsyncRequest('EntregaPremio',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_EntregaPremio: TEntregaPremio;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('EntregaPremio');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TEntregaPremio), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosPremio(const PremioID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosPremio');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosPremio');
    lMessage.Write('PremioID', TypeInfo(Integer), PremioID, []);
    __DispatchAsyncRequest('DatosPremio',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosPremio: TDatosPremio;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosPremio');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosPremio), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ValidaConsumo(const Consumo: TConsumoExpress);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ValidaConsumo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ValidaConsumo');
    lMessage.Write('Consumo', TypeInfo(TConsumoExpress), Consumo, []);
    __DispatchAsyncRequest('ValidaConsumo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ValidaConsumo: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ValidaConsumo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AgrupacionesBomba(const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AgrupacionesBomba');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AgrupacionesBomba');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('AgrupacionesBomba',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_AgrupacionesBomba: AAgrupacion;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('AgrupacionesBomba');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AAgrupacion), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosCerrarLiquidacion(const EstacionID: Integer; const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosCerrarLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosCerrarLiquidacion');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('DatosCerrarLiquidacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosCerrarLiquidacion: TDatosCerrarLiquidacion;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosCerrarLiquidacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosCerrarLiquidacion), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ProcesaVentasLiquidacion(const Datos: TDatosCerrarLiquidacion);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ProcesaVentasLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ProcesaVentasLiquidacion');
    lMessage.Write('Datos', TypeInfo(TDatosCerrarLiquidacion), Datos, []);
    __DispatchAsyncRequest('ProcesaVentasLiquidacion',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_TicketsLiquidacion(const LiquidacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('TicketsLiquidacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'TicketsLiquidacion');
    lMessage.Write('LiquidacionID', TypeInfo(Integer), LiquidacionID, []);
    __DispatchAsyncRequest('TicketsLiquidacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_TicketsLiquidacion: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('TicketsLiquidacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ValidaFolioFactura(const Serie: AnsiString; const Folio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ValidaFolioFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ValidaFolioFactura');
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    __DispatchAsyncRequest('ValidaFolioFactura',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ValidaFolioFactura: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ValidaFolioFactura');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PuntosGuardaCriterios(const PuntosCriterioID: Integer; const Datos: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PuntosGuardaCriterios');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PuntosGuardaCriterios');
    lMessage.Write('PuntosCriterioID', TypeInfo(Integer), PuntosCriterioID, []);
    lMessage.Write('Datos', TypeInfo(AnsiString), Datos, []);
    __DispatchAsyncRequest('PuntosGuardaCriterios',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosFacturaElectronica(const FacturaID: Integer; const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosFacturaElectronica');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosFacturaElectronica');
    lMessage.Write('FacturaID', TypeInfo(Integer), FacturaID, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('DatosFacturaElectronica',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosFacturaElectronica: TFacturaElectronica;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosFacturaElectronica');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TFacturaElectronica), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_LlavePrivaCertificado(const LlavePrivada: AnsiString; const Certificado: AnsiString; const GasolineroID: Integer;
	const Password: AnsiString; const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('LlavePrivaCertificado');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'LlavePrivaCertificado');
    lMessage.Write('LlavePrivada', TypeInfo(AnsiString), LlavePrivada, []);
    lMessage.Write('Certificado', TypeInfo(AnsiString), Certificado, []);
    lMessage.Write('GasolineroID', TypeInfo(Integer), GasolineroID, []);
    lMessage.Write('Password', TypeInfo(AnsiString), Password, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('LlavePrivaCertificado',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_LlavePrivaCertificado: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('LlavePrivaCertificado');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_SELLOPEMs(const Texto: UnicodeString; const EstacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('SELLOPEMs');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'SELLOPEMs');
    lMessage.Write('Texto', TypeInfo(UnicodeString), Texto, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    __DispatchAsyncRequest('SELLOPEMs',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_SELLOPEMs: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('SELLOPEMs');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CERs(const DIR: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CERs');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CERs');
    lMessage.Write('DIR', TypeInfo(AnsiString), DIR, []);
    __DispatchAsyncRequest('CERs',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CERs: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CERs');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ValidaLiquidacionDespachador(const LiquidacionID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ValidaLiquidacionDespachador');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ValidaLiquidacionDespachador');
    lMessage.Write('LiquidacionID', TypeInfo(Integer), LiquidacionID, []);
    __DispatchAsyncRequest('ValidaLiquidacionDespachador',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ValidaLiquidacionDespachador: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ValidaLiquidacionDespachador');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaLiquidacionProd(const Estacion: Integer; const FechaIni: DateTime; const FechaFin: DateTime;
	const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaLiquidacionProd');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaLiquidacionProd');
    lMessage.Write('Estacion', TypeInfo(Integer), Estacion, []);
    lMessage.Write('FechaIni', TypeInfo(DateTime), FechaIni, [paIsDateTime]);
    lMessage.Write('FechaFin', TypeInfo(DateTime), FechaFin, [paIsDateTime]);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('ActualizaLiquidacionProd',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ActualizaLiquidacionProd: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ActualizaLiquidacionProd');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PuntosDespachador(const TurnoID: Integer; const EstacionID: Integer; const UsuarioID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PuntosDespachador');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PuntosDespachador');
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    __DispatchAsyncRequest('PuntosDespachador',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardarDatosFacturaPemex(const DatosFacturaPemex: TDatosFacturaPemex);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardarDatosFacturaPemex');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardarDatosFacturaPemex');
    lMessage.Write('DatosFacturaPemex', TypeInfo(TDatosFacturaPemex), DatosFacturaPemex, []);
    __DispatchAsyncRequest('GuardarDatosFacturaPemex',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AfectaInventarios(const LiquidacionID: Integer; const UsuarioID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AfectaInventarios');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AfectaInventarios');
    lMessage.Write('LiquidacionID', TypeInfo(Integer), LiquidacionID, []);
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    __DispatchAsyncRequest('AfectaInventarios',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_AfectaInventarios: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('AfectaInventarios');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_InsertaFacturaElectronica(const FacturaElectronicaID: Integer; const CadenaOriginal: UnicodeString;
	const SelloDigital: UnicodeString; const FacturaID: Integer; const Vigencia: Boolean;
	const Enviado: Boolean; const NoCertificado: AnsiString; const NoAprobacion: AnsiString;
	const FechaAprobacion: DateTime);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('InsertaFacturaElectronica');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'InsertaFacturaElectronica');
    lMessage.Write('FacturaElectronicaID', TypeInfo(Integer), FacturaElectronicaID, []);
    lMessage.Write('CadenaOriginal', TypeInfo(UnicodeString), CadenaOriginal, []);
    lMessage.Write('SelloDigital', TypeInfo(UnicodeString), SelloDigital, []);
    lMessage.Write('FacturaID', TypeInfo(Integer), FacturaID, []);
    lMessage.Write('Vigencia', TypeInfo(Boolean), Vigencia, []);
    lMessage.Write('Enviado', TypeInfo(Boolean), Enviado, []);
    lMessage.Write('NoCertificado', TypeInfo(AnsiString), NoCertificado, []);
    lMessage.Write('NoAprobacion', TypeInfo(AnsiString), NoAprobacion, []);
    lMessage.Write('FechaAprobacion', TypeInfo(DateTime), FechaAprobacion, [paIsDateTime]);
    __DispatchAsyncRequest('InsertaFacturaElectronica',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CERsNUM(const DIR: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CERsNUM');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CERsNUM');
    lMessage.Write('DIR', TypeInfo(AnsiString), DIR, []);
    __DispatchAsyncRequest('CERsNUM',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CERsNUM: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CERsNUM');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaFirmaDefault(const UsuarioID: Integer; const FIRMA: Binary);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaFirmaDefault');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaFirmaDefault');
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    lMessage.Write('FIRMA', TypeInfo(Binary), FIRMA, []);
    __DispatchAsyncRequest('ActualizaFirmaDefault',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ActualizaFirmaDefault: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ActualizaFirmaDefault');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_obtendatosempleados(const EstacionID: AnsiString; const Turno: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('obtendatosempleados');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'obtendatosempleados');
    lMessage.Write('EstacionID', TypeInfo(AnsiString), EstacionID, []);
    lMessage.Write('Turno', TypeInfo(AnsiString), Turno, []);
    __DispatchAsyncRequest('obtendatosempleados',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_obtendatosempleados: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('obtendatosempleados');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ProgramaMantenimiento(const IDPROGRAMAMANTENIMIENTO: Integer; const IDESTACION: Integer;
	const FECHA: DateTime);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ProgramaMantenimiento');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ProgramaMantenimiento');
    lMessage.Write('IDPROGRAMAMANTENIMIENTO', TypeInfo(Integer), IDPROGRAMAMANTENIMIENTO, []);
    lMessage.Write('IDESTACION', TypeInfo(Integer), IDESTACION, []);
    lMessage.Write('FECHA', TypeInfo(DateTime), FECHA, [paIsDateTime]);
    __DispatchAsyncRequest('ProgramaMantenimiento',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_obtendatosActividadesProgramadas(const IDESTACION: Integer; const TIPO: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('obtendatosActividadesProgramadas');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'obtendatosActividadesProgramadas');
    lMessage.Write('IDESTACION', TypeInfo(Integer), IDESTACION, []);
    lMessage.Write('TIPO', TypeInfo(Integer), TIPO, []);
    __DispatchAsyncRequest('obtendatosActividadesProgramadas',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_obtendatosActividadesProgramadas: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('obtendatosActividadesProgramadas');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_obtenNotificacionesDiarias(const IDESTACION: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('obtenNotificacionesDiarias');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'obtenNotificacionesDiarias');
    lMessage.Write('IDESTACION', TypeInfo(Integer), IDESTACION, []);
    __DispatchAsyncRequest('obtenNotificacionesDiarias',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_obtenNotificacionesDiarias: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('obtenNotificacionesDiarias');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_registraactividadrealizada(const IDACTIVIDADMANTENIMIENTO: Integer; const NOTA: AnsiString; const STATUS: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('registraactividadrealizada');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'registraactividadrealizada');
    lMessage.Write('IDACTIVIDADMANTENIMIENTO', TypeInfo(Integer), IDACTIVIDADMANTENIMIENTO, []);
    lMessage.Write('NOTA', TypeInfo(AnsiString), NOTA, []);
    lMessage.Write('STATUS', TypeInfo(AnsiString), STATUS, []);
    __DispatchAsyncRequest('registraactividadrealizada',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_registraactividadrealizada: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('registraactividadrealizada');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CancelarLote(const LoteID: Integer; const UsuarioID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CancelarLote');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CancelarLote');
    lMessage.Write('LoteID', TypeInfo(Integer), LoteID, []);
    lMessage.Write('UsuarioID', TypeInfo(Integer), UsuarioID, []);
    __DispatchAsyncRequest('CancelarLote',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CancelarLote: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CancelarLote');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_StatusCupon(const Codigo: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('StatusCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'StatusCupon');
    lMessage.Write('Codigo', TypeInfo(AnsiString), Codigo, []);
    __DispatchAsyncRequest('StatusCupon',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_StatusCupon: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('StatusCupon');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscarReporte(const Nombre: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscarReporte');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscarReporte');
    lMessage.Write('Nombre', TypeInfo(AnsiString), Nombre, []);
    __DispatchAsyncRequest('BuscarReporte',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscarReporte: TReporte;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('BuscarReporte');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TReporte), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GeneraCupones(const LoteCuponID: Integer; const ClienteID: Integer; const EstacionID: Integer;
	const Identificador: Integer; const Cupones: AGeneraCupon; const TipoCupon: Boolean;
	const Serie: AnsiString; const aFolio: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GeneraCupones');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GeneraCupones');
    lMessage.Write('LoteCuponID', TypeInfo(Integer), LoteCuponID, []);
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('Identificador', TypeInfo(Integer), Identificador, []);
    lMessage.Write('Cupones', TypeInfo(AGeneraCupon), Cupones, []);
    lMessage.Write('TipoCupon', TypeInfo(Boolean), TipoCupon, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('aFolio', TypeInfo(Integer), aFolio, []);
    __DispatchAsyncRequest('GeneraCupones',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DocumentosConSaldo(const ClienteID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DocumentosConSaldo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DocumentosConSaldo');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    __DispatchAsyncRequest('DocumentosConSaldo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DocumentosConSaldo: TDocumentosConSaldoArray;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DocumentosConSaldo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDocumentosConSaldoArray), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_FacturaRecibo(const Cliente: Integer; const Importe: Double; const EstacionID: Integer;
	const EmpleadoID: Integer; const SerieFactura: AnsiString; const ProductoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FacturaRecibo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'FacturaRecibo');
    lMessage.Write('Cliente', TypeInfo(Integer), Cliente, []);
    lMessage.Write('Importe', TypeInfo(Double), Importe, []);
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('EmpleadoID', TypeInfo(Integer), EmpleadoID, []);
    lMessage.Write('SerieFactura', TypeInfo(AnsiString), SerieFactura, []);
    lMessage.Write('ProductoID', TypeInfo(Integer), ProductoID, []);
    __DispatchAsyncRequest('FacturaRecibo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_FacturaRecibo: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('FacturaRecibo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CaracteresCupon;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CaracteresCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CaracteresCupon');
    __DispatchAsyncRequest('CaracteresCupon',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CaracteresCupon: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CaracteresCupon');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ObtenCuponValido(const Barras: AnsiString; const Grupo: Integer; const CuponAutoriza: TAutoriza);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ObtenCuponValido');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ObtenCuponValido');
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    lMessage.Write('Grupo', TypeInfo(Integer), Grupo, []);
    lMessage.Write('CuponAutoriza', TypeInfo(TAutoriza), CuponAutoriza, []);
    __DispatchAsyncRequest('ObtenCuponValido',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ObtenCuponValido: TCuponValido;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('ObtenCuponValido');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TCuponValido), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardaAutorizacion(const Autorizacion: TAutoriza);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardaAutorizacion');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardaAutorizacion');
    lMessage.Write('Autorizacion', TypeInfo(TAutoriza), Autorizacion, []);
    __DispatchAsyncRequest('GuardaAutorizacion',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GuardaAutorizacion: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GuardaAutorizacion');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosVehiculo(const VehiculoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosVehiculo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosVehiculo');
    lMessage.Write('VehiculoID', TypeInfo(Integer), VehiculoID, []);
    __DispatchAsyncRequest('DatosVehiculo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosVehiculo: TDatosVehiculo;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosVehiculo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosVehiculo), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CancelaGrupo(const Grupo: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CancelaGrupo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CancelaGrupo');
    lMessage.Write('Grupo', TypeInfo(Integer), Grupo, []);
    __DispatchAsyncRequest('CancelaGrupo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CancelaGrupo: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CancelaGrupo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_QuemarCupon(const Consumo: TConsumo; const Barras: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('QuemarCupon');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'QuemarCupon');
    lMessage.Write('Consumo', TypeInfo(TConsumo), Consumo, []);
    lMessage.Write('Barras', TypeInfo(AnsiString), Barras, []);
    __DispatchAsyncRequest('QuemarCupon',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_QuemarCupon: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('QuemarCupon');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardarConsumo(const Consumo: TConsumo);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardarConsumo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardarConsumo');
    lMessage.Write('Consumo', TypeInfo(TConsumo), Consumo, []);
    __DispatchAsyncRequest('GuardarConsumo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GuardarConsumo: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GuardarConsumo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosVerifica(const VehiculoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosVerifica');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosVerifica');
    lMessage.Write('VehiculoID', TypeInfo(Integer), VehiculoID, []);
    __DispatchAsyncRequest('DatosVerifica',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosVerifica: TDatosVerifica;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosVerifica');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosVerifica), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosVerificaReferencia(const Referencia: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosVerificaReferencia');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosVerificaReferencia');
    lMessage.Write('Referencia', TypeInfo(AnsiString), Referencia, []);
    __DispatchAsyncRequest('DatosVerificaReferencia',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosVerificaReferencia: TDatosVerifica;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('DatosVerificaReferencia');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TDatosVerifica), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_TarjetaConsumo(const Tarjeta: AnsiString; const Consumo: TConsumo);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('TarjetaConsumo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'TarjetaConsumo');
    lMessage.Write('Tarjeta', TypeInfo(AnsiString), Tarjeta, []);
    lMessage.Write('Consumo', TypeInfo(TConsumo), Consumo, []);
    __DispatchAsyncRequest('TarjetaConsumo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_TarjetaConsumo: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('TarjetaConsumo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ActualizaHistorial(const Consumo: TConsumo);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ActualizaHistorial');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ActualizaHistorial');
    lMessage.Write('Consumo', TypeInfo(TConsumo), Consumo, []);
    __DispatchAsyncRequest('ActualizaHistorial',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_EliminaAutorizacionVehiculo(const Referencia: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('EliminaAutorizacionVehiculo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'EliminaAutorizacionVehiculo');
    lMessage.Write('Referencia', TypeInfo(AnsiString), Referencia, []);
    __DispatchAsyncRequest('EliminaAutorizacionVehiculo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_EliminaAutorizacionVehiculo: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('EliminaAutorizacionVehiculo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AgregaSecuencias(const Consumos: aConsumo);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AgregaSecuencias');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AgregaSecuencias');
    lMessage.Write('Consumos', TypeInfo(aConsumo), Consumos, []);
    __DispatchAsyncRequest('AgregaSecuencias',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_AgregaSecuencias: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('AgregaSecuencias');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AutorizaTarjeta(const Autoriza: TAutoriza);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AutorizaTarjeta');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AutorizaTarjeta');
    lMessage.Write('Autoriza', TypeInfo(TAutoriza), Autoriza, []);
    __DispatchAsyncRequest('AutorizaTarjeta',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_AutorizaTarjeta: TTarjeta;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('AutorizaTarjeta');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TTarjeta), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_BuscaAutorizacionTarjeta(const ClienteID: Integer; const VehiculoID: Integer; const GasolineroID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('BuscaAutorizacionTarjeta');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'BuscaAutorizacionTarjeta');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('VehiculoID', TypeInfo(Integer), VehiculoID, []);
    lMessage.Write('GasolineroID', TypeInfo(Integer), GasolineroID, []);
    __DispatchAsyncRequest('BuscaAutorizacionTarjeta',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_BuscaAutorizacionTarjeta: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('BuscaAutorizacionTarjeta');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_EstadoDispensario(const Dispensario: Integer; const Estado: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('EstadoDispensario');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'EstadoDispensario');
    lMessage.Write('Dispensario', TypeInfo(Integer), Dispensario, []);
    lMessage.Write('Estado', TypeInfo(AnsiString), Estado, []);
    __DispatchAsyncRequest('EstadoDispensario',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_EntradaBitacora(const Descripcion: AnsiString; const Tipo: eTipoBitacora; const Alerta: Boolean);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('EntradaBitacora');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'EntradaBitacora');
    lMessage.Write('Descripcion', TypeInfo(AnsiString), Descripcion, []);
    lMessage.Write('Tipo', TypeInfo(eTipoBitacora), Tipo, []);
    lMessage.Write('Alerta', TypeInfo(Boolean), Alerta, []);
    __DispatchAsyncRequest('EntradaBitacora',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AutoCambioPrecio;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AutoCambioPrecio');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AutoCambioPrecio');
    __DispatchAsyncRequest('AutoCambioPrecio',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CierraTurno(const BombaID: Integer; const TurnoID: Integer; const FinLecturas: aLecturas);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CierraTurno');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CierraTurno');
    lMessage.Write('BombaID', TypeInfo(Integer), BombaID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    lMessage.Write('FinLecturas', TypeInfo(aLecturas), FinLecturas, []);
    __DispatchAsyncRequest('CierraTurno',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CreaTurno(const BombaID: Integer; const TurnoID: Integer; const InicioLecturas: aLecturas);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CreaTurno');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CreaTurno');
    lMessage.Write('BombaID', TypeInfo(Integer), BombaID, []);
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    lMessage.Write('InicioLecturas', TypeInfo(aLecturas), InicioLecturas, []);
    __DispatchAsyncRequest('CreaTurno',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GuardaVenta(const nBomba: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GuardaVenta');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GuardaVenta');
    lMessage.Write('nBomba', TypeInfo(Integer), nBomba, []);
    __DispatchAsyncRequest('GuardaVenta',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GuardaVenta: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GuardaVenta');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_UltimoTurnoBomba;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('UltimoTurnoBomba');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'UltimoTurnoBomba');
    __DispatchAsyncRequest('UltimoTurnoBomba',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_UltimoTurnoBomba: aTurnoBomba;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('UltimoTurnoBomba');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(aTurnoBomba), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ValidaSecuencias(const TurnoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ValidaSecuencias');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ValidaSecuencias');
    lMessage.Write('TurnoID', TypeInfo(Integer), TurnoID, []);
    __DispatchAsyncRequest('ValidaSecuencias',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_ValidaSecuenciasC(const EstacionID: Integer; const Secuencias: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ValidaSecuenciasC');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'ValidaSecuenciasC');
    lMessage.Write('EstacionID', TypeInfo(Integer), EstacionID, []);
    lMessage.Write('Secuencias', TypeInfo(AnsiString), Secuencias, []);
    __DispatchAsyncRequest('ValidaSecuenciasC',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_ValidaSecuenciasC: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('ValidaSecuenciasC');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_Datos;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('Datos');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'Datos');
    __DispatchAsyncRequest('Datos',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_Datos: TGlobal;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('Datos');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(TGlobal), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CancelaGrupoC(const BombaID: Integer; const Grupo: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CancelaGrupoC');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CancelaGrupoC');
    lMessage.Write('BombaID', TypeInfo(Integer), BombaID, []);
    lMessage.Write('Grupo', TypeInfo(Integer), Grupo, []);
    __DispatchAsyncRequest('CancelaGrupoC',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PrefijaGrupo(const Bomba: Integer; const Grupo: Integer; const Terminal: AnsiString;
	const Cupon: TCupon);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PrefijaGrupo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PrefijaGrupo');
    lMessage.Write('Bomba', TypeInfo(Integer), Bomba, []);
    lMessage.Write('Grupo', TypeInfo(Integer), Grupo, []);
    lMessage.Write('Terminal', TypeInfo(AnsiString), Terminal, []);
    lMessage.Write('Cupon', TypeInfo(TCupon), Cupon, []);
    __DispatchAsyncRequest('PrefijaGrupo',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PrefijaGrupo: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('PrefijaGrupo');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PrefijaTarjeta(const nBomba: Integer; const Tarjeta: AnsiString; const NIP: AnsiString;
	const Odometro: AnsiString; const Terminal: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PrefijaTarjeta');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PrefijaTarjeta');
    lMessage.Write('nBomba', TypeInfo(Integer), nBomba, []);
    lMessage.Write('Tarjeta', TypeInfo(AnsiString), Tarjeta, []);
    lMessage.Write('NIP', TypeInfo(AnsiString), NIP, []);
    lMessage.Write('Odometro', TypeInfo(AnsiString), Odometro, []);
    lMessage.Write('Terminal', TypeInfo(AnsiString), Terminal, []);
    __DispatchAsyncRequest('PrefijaTarjeta',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PrefijaTarjeta: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('PrefijaTarjeta');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AsignaBombas;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AsignaBombas');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AsignaBombas');
    __DispatchAsyncRequest('AsignaBombas',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AsignaProductos;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AsignaProductos');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AsignaProductos');
    __DispatchAsyncRequest('AsignaProductos',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AsignaDispositivo;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AsignaDispositivo');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AsignaDispositivo');
    __DispatchAsyncRequest('AsignaDispositivo',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_AsignaTanques;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('AsignaTanques');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'AsignaTanques');
    __DispatchAsyncRequest('AsignaTanques',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_IncrementarImpreso(const Secuencia: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('IncrementarImpreso');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'IncrementarImpreso');
    lMessage.Write('Secuencia', TypeInfo(Integer), Secuencia, []);
    __DispatchAsyncRequest('IncrementarImpreso',lMessage, false);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_PrefijaTarjetaFrecuente(const nBomba: Integer; const Tarjeta: AnsiString; const Odometro: AnsiString;
	const Terminal: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('PrefijaTarjetaFrecuente');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'PrefijaTarjetaFrecuente');
    lMessage.Write('nBomba', TypeInfo(Integer), nBomba, []);
    lMessage.Write('Tarjeta', TypeInfo(AnsiString), Tarjeta, []);
    lMessage.Write('Odometro', TypeInfo(AnsiString), Odometro, []);
    lMessage.Write('Terminal', TypeInfo(AnsiString), Terminal, []);
    __DispatchAsyncRequest('PrefijaTarjetaFrecuente',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_PrefijaTarjetaFrecuente: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('PrefijaTarjetaFrecuente');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GenerarFacturas(const Serie: AnsiString; const fol: Integer; const FechaCorte: DateTime;
	const FechaContable: DateTime; const DiaFacturar: Integer; const Magna: Boolean;
	const Premium: Boolean; const Diesel: Boolean; const EmpleadoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GenerarFacturas');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GenerarFacturas');
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('fol', TypeInfo(Integer), fol, []);
    lMessage.Write('FechaCorte', TypeInfo(DateTime), FechaCorte, [paIsDateTime]);
    lMessage.Write('FechaContable', TypeInfo(DateTime), FechaContable, [paIsDateTime]);
    lMessage.Write('DiaFacturar', TypeInfo(Integer), DiaFacturar, []);
    lMessage.Write('Magna', TypeInfo(Boolean), Magna, []);
    lMessage.Write('Premium', TypeInfo(Boolean), Premium, []);
    lMessage.Write('Diesel', TypeInfo(Boolean), Diesel, []);
    lMessage.Write('EmpleadoID', TypeInfo(Integer), EmpleadoID, []);
    __DispatchAsyncRequest('GenerarFacturas',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GenerarFacturas: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GenerarFacturas');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_EliminaFactura(const Folio: Integer; const Serie: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('EliminaFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'EliminaFactura');
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    __DispatchAsyncRequest('EliminaFactura',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_EliminaFactura: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('EliminaFactura');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_CambioFactura(const Serie: AnsiString; const Folio: Integer; const NuevaSerie: AnsiString;
	const NuevoFolio: Integer; const FechaImpresion: DateTime);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('CambioFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'CambioFactura');
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    lMessage.Write('NuevaSerie', TypeInfo(AnsiString), NuevaSerie, []);
    lMessage.Write('NuevoFolio', TypeInfo(Integer), NuevoFolio, []);
    lMessage.Write('FechaImpresion', TypeInfo(DateTime), FechaImpresion, [paIsDateTime]);
    __DispatchAsyncRequest('CambioFactura',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_CambioFactura: AnsiString;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('CambioFactura');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(AnsiString), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_DatosFactura(const Folio: Integer; const Serie: AnsiString);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('DatosFactura');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'DatosFactura');
    lMessage.Write('Folio', TypeInfo(Integer), Folio, []);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    __DispatchAsyncRequest('DatosFactura',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_DatosFactura: Boolean;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('DatosFactura');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Boolean), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GeneraFacturasXCliente(const ClienteID: Integer; const Productos: AnsiString; const FechaCorte: DateTime;
	const FechaContable: DateTime; const Serie: AnsiString; const aFolio: Integer;
	const EmpleadoID: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GeneraFacturasXCliente');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GeneraFacturasXCliente');
    lMessage.Write('ClienteID', TypeInfo(Integer), ClienteID, []);
    lMessage.Write('Productos', TypeInfo(AnsiString), Productos, []);
    lMessage.Write('FechaCorte', TypeInfo(DateTime), FechaCorte, [paIsDateTime]);
    lMessage.Write('FechaContable', TypeInfo(DateTime), FechaContable, [paIsDateTime]);
    lMessage.Write('Serie', TypeInfo(AnsiString), Serie, []);
    lMessage.Write('aFolio', TypeInfo(Integer), aFolio, []);
    lMessage.Write('EmpleadoID', TypeInfo(Integer), EmpleadoID, []);
    __DispatchAsyncRequest('GeneraFacturasXCliente',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GeneraFacturasXCliente: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GeneraFacturasXCliente');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TServiceValesCupones_AsyncProxy.Invoke_GasolineroID;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GasolineroID');

    lMessage.InitializeRequestMessage(lTransportChannel, 'LibraryValesCupones', __InterfaceName, 'GasolineroID');
    __DispatchAsyncRequest('GasolineroID',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TServiceValesCupones_AsyncProxy.Retrieve_GasolineroID: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GasolineroID');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;


initialization
end.
